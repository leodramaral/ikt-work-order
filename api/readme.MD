# Work Order

# üìã Documenta√ß√£o da API - Work Order System

## üèóÔ∏è Vis√£o Geral da Arquitetura

Esta API foi desenvolvida seguindo os princ√≠pios da **Clean Architecture** (Arquitetura Limpa), com forte separa√ß√£o de responsabilidades e alta testabilidade.

### Stack Tecnol√≥gica
- **Runtime**: Node.js com TypeScript
- **Framework Web**: Express.js
- **ORM**: TypeORM
- **Banco de Dados**: PostgreSQL
- **Testes**: Jest + ts-jest
- **Build Tools**: ts-node

---

## üéØ Padr√µes de Projeto Implementados

### 1. **Clean Architecture**
A aplica√ß√£o est√° organizada em camadas com depend√™ncias unidirecionais:

```
Presentation Layer (api.ts)
       ‚Üì
Use Cases Layer (usecase/)
       ‚Üì
Domain Layer (domain/)
       ‚Üì
Infrastructure Layer (repository/, database/)
```

**Benef√≠cios:**
- Independ√™ncia de frameworks
- Testabilidade sem banco de dados
- Regras de neg√≥cio isoladas
- Facilidade para trocar infraestrutura

### 2. **Repository Pattern**
Abstra√ß√£o do acesso a dados atrav√©s de interfaces, permitindo m√∫ltiplas implementa√ß√µes.

**Exemplo:**
```typescript
// Interface (Contrato)
interface AccountRepository {
    save(account: Account): Promise<{ id: string}>;
    getByEmail(email: string): Promise<Account | null>;
}

// Implementa√ß√£o concreta com TypeORM
class AccountRepositoryTypeORM implements AccountRepository {
    // Implementa√ß√£o espec√≠fica...
}
```

**Vantagens:**
- F√°cil de testar (pode usar reposit√≥rios fake)
- Desacoplamento da implementa√ß√£o do banco
- Possibilidade de trocar ORM sem impactar use cases

### 3. **Use Case Pattern (Interactors)**
Cada funcionalidade do sistema √© um use case independente.

**Estrutura:**
```typescript
export default class CreateWorkOrder {
    constructor(
        readonly workOrderRepository: WorkOrderRepository, 
        readonly taskRepository: TaskRepository
    ) { }

    async execute(input: Input): Promise<string> {
        // L√≥gica de neg√≥cio aqui
    }
}
```

**Use Cases implementados:**
- `Signup` - Cadastro de usu√°rios
- `Login` - Autentica√ß√£o
- `GetTasks` - Listagem de tarefas
- `CreateWorkOrder` - Cria√ß√£o de ordens de trabalho
- `GetWorkOrders` - Listagem de ordens de trabalho

### 4. **Dependency Injection**
Inje√ß√£o de depend√™ncias manual no ponto de entrada da aplica√ß√£o (api.ts).

```typescript
const accountRepository = new AccountRepositoryTypeORM();
const signup = new Signup(accountRepository);
const login = new Login(accountRepository);
```

### 5. **Entity Pattern (Domain Models)**
Entidades com valida√ß√£o e comportamento encapsulado.

**Caracter√≠sticas:**
- Valida√ß√£o de dados no `@BeforeInsert()`
- Factory methods est√°ticos (`create()`)
- M√©todos de comportamento (`addTask()`, `removeTask()`)

---

## üìÇ Estrutura de Camadas

### üé® **1. Domain Layer** (`domain/`)
Camada mais interna - cont√©m as entidades de neg√≥cio.

#### `Account.ts`
Representa uma conta de usu√°rio.

**Atributos:**
- `id`: UUID √∫nico
- `name`: Nome do usu√°rio
- `email`: Email √∫nico
- `passwordHash`: Senha criptografada
- `createdAt`: Data de cria√ß√£o

**Valida√ß√µes:**
- Nome m√≠nimo de 2 caracteres
- Email deve conter `@`
- Password hash m√≠nimo de 6 caracteres

#### `Task.ts`
Representa uma tarefa individual.

**Atributos:**
- `id`: UUID √∫nico
- `title`: T√≠tulo da tarefa
- `description`: Descri√ß√£o opcional
- `createdAt`: Data de cria√ß√£o
- `updatedAt`: Data de atualiza√ß√£o

#### `WorkOrder.ts`
Representa uma ordem de trabalho (agrupamento de tarefas).

**Atributos:**
- `id`: UUID √∫nico
- `title`: T√≠tulo da ordem
- `description`: Descri√ß√£o opcional
- `assignedTo`: Conta atribu√≠da (relacionamento ManyToOne)
- `tasks`: Lista de tarefas (relacionamento ManyToMany)
- `createdAt`: Data de cria√ß√£o
- `updatedAt`: Data de atualiza√ß√£o

**M√©todos:**
- `addTask(task: Task)`: Adiciona tarefa √† ordem
- `removeTask(taskId: string)`: Remove tarefa da ordem

**Relacionamentos:**
- Tabela de jun√ß√£o `work_order_tasks` para rela√ß√£o N:N com Tasks

---

### üîå **2. Repository Layer** (`repository/`)
Camada de acesso a dados - implementa o padr√£o Repository.

#### `AccountRepository.ts`
```typescript
interface AccountRepository {
    save(account: Account): Promise<{ id: string}>;
    getByEmail(email: string): Promise<Account | null>;
}
```

#### `TaskRepository.ts`
```typescript
interface TaskRepository {
    findAll(): Promise<Task[]>;
    findByIds(ids: string[]): Promise<Task[]>;
}
```

#### `WorkOrderRepository.ts`
```typescript
interface WorkOrderRepository {
    save(workOrder: WorkOrder): Promise<WorkOrder>;
    findAll(): Promise<WorkOrder[]>;
}
```

**Implementa√ß√µes TypeORM:**
- Todas as interfaces t√™m implementa√ß√£o concreta usando TypeORM
- Usam `AppDataSource.getRepository()` para acesso ao banco
- Suporte a eager loading de relacionamentos

---

### üíº **3. Use Case Layer** (`usecase/`)
Camada de l√≥gica de neg√≥cio - orquestra opera√ß√µes.

#### `Signup.ts`
**Responsabilidade:** Cadastrar novo usu√°rio

**Input:**
```typescript
{
    name: string;
    email: string;
    password: string;
}
```

**Output:** `string` (id do usu√°rio criado)

**Fluxo:**
1. Cria entidade Account com dados validados
2. Salva no reposit√≥rio
3. Retorna ID gerado

#### `Login.ts`
**Responsabilidade:** Autenticar usu√°rio

**Input:**
```typescript
{
    email: string;
    password: string;
}
```

**Output:** `boolean` (sucesso/falha)

**Fluxo:**
1. Busca conta por email
2. Verifica se senha corresponde ao hash
3. Retorna resultado

‚ö†Ô∏è **Nota:** Implementa√ß√£o simplificada - em produ√ß√£o deveria usar bcrypt e JWT.

#### `GetTasks.ts`
**Responsabilidade:** Listar todas as tarefas dispon√≠veis

**Output:**
```typescript
Array<{
    id: string;
    title: string;
    description?: string;
}>
```

#### `CreateWorkOrder.ts`
**Responsabilidade:** Criar ordem de trabalho com tarefas

**Input:**
```typescript
{
    title: string;
    description?: string;
    taskIds: string[];
}
```

**Output:** `string` (id da ordem criada)

**Fluxo:**
1. Busca tasks pelos IDs fornecidos
2. Valida se todas as tasks existem
3. Cria WorkOrder
4. Associa tasks √† ordem
5. Persiste no banco
6. Retorna ID

**Valida√ß√£o:** Lan√ßa erro se algum taskId n√£o existir.

#### `GetWorkOrders.ts`
**Responsabilidade:** Listar ordens de trabalho com suas tarefas

**Output:**
```typescript
Array<{
    id: string;
    title: string;
    description?: string;
    tasks: Array<{
        id: string;
        title: string;
        description?: string;
    }>;
    createdAt: Date;
}>
```

---

### üåê **4. Presentation Layer** (`api.ts`)
Camada de entrada HTTP - adaptadores Express.

**Endpoints:**

| M√©todo | Rota | Use Case | Descri√ß√£o |
|--------|------|----------|-----------|
| POST | `/signup` | Signup | Cadastra usu√°rio |
| POST | `/login` | Login | Autentica usu√°rio |
| GET | `/tasks` | GetTasks | Lista tarefas |
| GET | `/work-orders` | GetWorkOrders | Lista ordens |
| POST | `/work-orders` | CreateWorkOrder | Cria ordem |

**Padr√£o de resposta:**
- **Sucesso:** Status 200/201 + dados no body
- **Erro:** Status 500 + `{ message: string }`

**Exemplo de handler:**
```typescript
app.post('/work-orders', async (req: Request, res: Response) => {
    try {
        const input = req.body;
        const workOrderId = await createWorkOrder.execute(input);
        res.status(201).json({ id: workOrderId });
    }
    catch (e: any) {
        res.status(500).json({ message: e.message });
    }
});
```

---

### üóÑÔ∏è **5. Infrastructure Layer** (`database/`)

#### `data-source.ts`
Configura√ß√£o do TypeORM DataSource.

**Configura√ß√£o:**
```typescript
{
    type: "postgres",
    host: "localhost",
    port: 5432,
    username: "admin",
    password: "password",
    database: "ikt_work_order",
    synchronize: true,  // ‚ö†Ô∏è Apenas para desenvolvimento
    entities: [Account, Task, WorkOrder],
    migrations: ["src/migrations/**/*.ts"]
}
```

#### Migrations
O projeto inclui migrations para:
1. **CreateAccountTable** - Tabela de contas
2. **CreateTaskAndWorkOrderTables** - Tabelas de tarefas e ordens
3. **SeedTasks** - Popula√ß√£o inicial de tarefas

---

## üß™ Testes

### Estrat√©gia de Testes
A arquitetura permite testes **sem depend√™ncia de banco de dados** usando reposit√≥rios fake.

### `User.test.ts`
**Tipo:** Teste Unit√°rio

**Objetivo:** Validar cria√ß√£o de entidade Account

```typescript
test('create a user', () => {
    const account = Account.create('Leandro', 'email@leandro.com', 'hashedpassword');
    expect(account).toBeInstanceOf(Account);
    expect(account.name).toBe('Leandro');
    expect(account.email).toBe('email@leandro.com');
    expect(account.passwordHash).toBe('hashedpassword');
});
```

### `CreateWorkOrder.test.ts`
**Tipo:** Teste de Integra√ß√£o (com mocks)

**Cen√°rios testados:**

#### ‚úÖ Cen√°rio 1: Cria√ß√£o bem-sucedida
```typescript
test("deve criar uma work order com tasks v√°lidas", async () => {
    const input = {
        title: "Sprint 1",
        description: "Primeira sprint do projeto",
        taskIds: ["task-1", "task-2"]
    };

    const workOrderId = await createWorkOrder.execute(input);
    
    expect(workOrderId).toBe("wo-1");
    // Valida que ordem foi salva com tasks corretas
});
```

#### ‚ùå Cen√°rio 2: Task inv√°lida
```typescript
test("deve lan√ßar exce√ß√£o ao tentar criar work order com task id inv√°lido", async () => {
    const input = {
        title: "Sprint 1",
        taskIds: ["task-1", "task-invalido"]
    };

    await expect(createWorkOrder.execute(input))
        .rejects.toThrow("Tasks n√£o encontradas: task-invalido");
});
```

### Implementa√ß√£o de Fakes

#### FakeTaskRepository
```typescript
class FakeTaskRepository implements TaskRepository {
    private tasks: Task[] = [
        // Tasks pr√©-configuradas
    ];

    async findAll(): Promise<Task[]> {
        return this.tasks;
    }

    async findByIds(ids: string[]): Promise<Task[]> {
        return this.tasks.filter(task => ids.includes(task.id));
    }
}
```

#### FakeWorkOrderRepository
```typescript
class FakeWorkOrderRepository implements WorkOrderRepository {
    private workOrders: WorkOrder[] = [];

    async save(workOrder: WorkOrder): Promise<WorkOrder> {
        // Simula salvamento em mem√≥ria
    }

    async findAll(): Promise<WorkOrder[]> {
        return this.workOrders;
    }
}
```

**Vantagens:**
- Testes r√°pidos (sem I/O de banco)
- Isolamento total de infraestrutura
- Facilidade para simular cen√°rios espec√≠ficos

### Configura√ß√£o de Testes (`jest.config.js`)
```javascript
module.exports = {
  testEnvironment: "node",
  transform: {
    ...tsJestTransformCfg,
  },
};
```

---

## ‚úÖ Boas Pr√°ticas Implementadas

1. **Separa√ß√£o de Concerns**: Cada camada tem responsabilidade bem definida
2. **Dependency Injection**: Facilita testes e manuten√ß√£o
3. **Type Safety**: TypeScript em toda aplica√ß√£o
4. **Error Handling**: Try-catch em todos os handlers
5. **Valida√ß√£o**: Entidades validam seus pr√≥prios dados
6. **Testes Isolados**: Uso de fakes/mocks para testes unit√°rios
7. **Factory Methods**: Cria√ß√£o de entidades via m√©todos est√°ticos
8. **DTO Pattern**: Input/Output types expl√≠citos nos use cases
9. **Repository Pattern**: Abstra√ß√£o do acesso a dados
10. **Clean Architecture**: Depend√™ncias unidirecionais

---

## üîÆ Poss√≠veis Melhorias Futuras

1. **Autentica√ß√£o robusta**: Implementar JWT + bcrypt
2. **Valida√ß√£o de input**: Usar biblioteca como Zod ou class-validator
3. **Pagina√ß√£o**: Adicionar pagina√ß√£o nas listagens
4. **Status codes**: Diferenciar 400, 404, 500 adequadamente
5. **Logging**: Implementar Winston ou Pino
6. **Documentation**: Adicionar Swagger/OpenAPI
7. **DI Container**: Usar InversifyJS ou TSyringe
8. **Event Sourcing**: Para audit trail
9. **CQRS**: Separar comandos de queries
10. **Testes E2E**: Adicionar testes de ponta a ponta

---

Esta documenta√ß√£o reflete uma aplica√ß√£o bem estruturada seguindo os princ√≠pios da Clean Architecture, com forte separa√ß√£o de responsabilidades, alta testabilidade e c√≥digo limpo e manuten√≠vel.
